<?php

/*
というわけで、以下はエラーハンドリングとしてtry/catchを組み合わせて
さらにパワーアップした例です！ここまでくれば、実際のプロジェクトでも
十分使えるコードといえるでしょう。
*/

class Hoge {
    public $color;

    // 引数のエラーハンドリングを強化
    public function hogeCall($i1 = null, $i2 = "") {
        try {
            // $i1がnullの場合は例外を投げる
            if (!isset($i1)) {
                throw new Exception("最低１個の引数をセットしてください！");
            }
            echo $i1;
            echo $i2;
            echo "\n";
        } catch (Exception $e) {
            // 例外が発生した場合の処理
            echo "エラー発生: " . $e->getMessage() . "\n";
        }
    }

    public function hogeColor() {
        if (isset($this->color)) {
            echo "色が" . $this->color . "に設定されていますよ\n";
        } else {
            echo "色が未設定です\n";
        }
    }
}

// 実際の利用例
$hoge_obj = new Hoge();

// 色が設定されていない状態での確認
$hoge_obj->hogeColor();

// 色を設定
$hoge_obj->color = "red";

// 引数がない場合のエラーハンドリング
$hoge_obj->hogeCall();  // ここで例外が発生し、エラーメッセージが表示される

// 引数1個の場合
$hoge_obj->hogeCall("ほげええ");  // 正常動作

// 引数2個の場合
$hoge_obj->hogeCall("MAZDAAAAA", "なぜ撃ったあああアアアア！？");  // 正常動作

// 色が設定された状態での確認
$hoge_obj->hogeColor();


/*
上記のように、エラー関連処理を強化するとコードの分量は増加します。
ただし、適切なエラー処理の実装を行うと、プログラマ自身のミスに気づきやすく
なったり、プログラム自体の欠陥箇所を判定するのに役立つため、省略するべきでは
ありません。
開発フェーズではなく、運用フェーズであっても、何が原因で壊れているのか？などの
判定が容易なことはシステムの維持・管理の可否に直結します。
繰り返しになりますが、プログラムは最終的には「動けばいい」では済みません。
むしろ動くことは当然であり、そのうえで、いかに品質が良いコードを書くことができるか？が
プログラマとして非常に重要な能力となってきます。
*/

?>
